#wipes-v4.py - by Mark Harris. Modified from JJSilva's NeoSectional Script located; https://github.com/JJSilva/NeoSectional/blob/master/metar.py

#testing custom wipes using airport's lat/lon

#Import needed libraries
import urllib2
import xml.etree.ElementTree as ET
import time
from neopixel import *
import sys
import os
import math
import random

#Setup for IC238 Light Sensor for LED Dimming, does not need to be commented out if sensor is not used, map will remain at full brightness.
#For more info on the sensor visit; http://www.uugear.com/portfolio/using-light-sensor-module-with-raspberry-pi/
import RPi.GPIO as GPIO
GPIO.setmode(GPIO.BCM)  #set mode to BCM and use BCM pin numbering, rather than BOARD pin numbering.
GPIO.setup(4, GPIO.IN)  #set pin 4 as input for light sensor, if one is used. If no sensor used board remains at high brightness always.
GPIO.setup(22, GPIO.IN, pull_up_down=GPIO.PUD_UP) #set pin 22 to momentary push button to force FAA Weather Data update if button is used.

#LED strip configuration YOU MUST CHANGE LED_COUNT VALUE TO MATCH YOUR SETUP:
LED_COUNT      = 60      #Number of LED pixels. Change this value to match the number of LED's being used on map
LED_PIN        = 18      #GPIO pin connected to the pixels (18 uses PWM!).
#LED_PIN        = 10     #GPIO pin connected to the pixels (10 uses SPI /dev/spidev0.0).
LED_FREQ_HZ    = 800000  #LED signal frequency in hertz (usually 800khz)
LED_DMA        = 5       #DMA channel to use for generating signal (try 5)
LED_INVERT     = False   #True to invert the signal (when using NPN transistor level shift)
LED_CHANNEL    = 0       #set to '1' for GPIOs 13, 19, 41, 45 or 53
LED_STRIP      = ws.WS2811_STRIP_GRB #Strip type and color ordering
LED_BRIGHTNESS = 255     #starting brightness. It will be changed below.

#Misc settings
rgb_grb = 1             #1 = RGB color codes. 0 = GRB color codes. Populate color codes below with normal RGB codes and script will change it as necessary

ap_id = []      #Used for screen wipes
latlist = []    #Used for screen wipes
lonlist = []    #Used for screen wipes

#Create an instance of NeoPixel
strip = Adafruit_NeoPixel(LED_COUNT, LED_PIN, LED_FREQ_HZ, LED_DMA, LED_INVERT, LED_BRIGHTNESS, LED_CHANNEL, LED_STRIP)
strip.begin()

#Functions
#Rainbow Animation functions - taken from https://github.com/JJSilva/NeoSectional/blob/master/metar.py
def wheel(pos):
    """Generate rainbow colors across 0-255 positions."""
    if pos < 85:
        return Color(pos * 3, 255 - pos * 3, 0)
    elif pos < 170:
        pos -= 85
        return Color(255 - pos * 3, 0, pos * 3)
    else:
        pos -= 170
        return Color(0, pos * 3, 255 - pos * 3)

def rainbowCycle(strip, iterations, wait_ms=2):
    """Draw rainbow that uniformly distributes itself across all pixels."""
    for j in range(256*iterations):
        for i in range(strip.numPixels()):
            strip.setPixelColor(i, wheel((int(i * 256 / strip.numPixels()) + j) & 255))
        strip.show()
        #time.sleep(wait_ms/1000.0)

#Generate random RGB color
def randcolor():
    r = int(random.randint(0,255))
    g = int(random.randint(0,255))
    b = int(random.randint(0,255))
    return Color(r,g,b)

#Change color code to work with various led strips. For instance, WS2812 model strip uses RGB where WS2811 model uses GRB
#Set the "rgb_grb" user setting above. 1 for RGB LED strip, and 0 for GRB strip.
def rgbtogrb(data,order=0):
    red = data[0]
    grn = data[1]
    blu = data[2]

    if order:
        data = [red,grn,blu]
    else:
        data =[grn,red,blu]
    return data

#range to loop through floats, rather than integers. Used to loop through lat/lons.
def frange(start, stop, step):
    if start != stop:
        i = start
        if i < stop:
            while i < stop:
                yield round(i,2)
                i += step
        else:
            while i > stop:
                yield round(i,2)
                i -= step

#Wipe routine based on Lat/Lons of airports on map.
#Need to pass name of dictionary with coordinates, either latdict or londict
#also need to pass starting value and ending values to iterate through. These are floats for Lat/Lon. ie. 36.23
#Pass Step value to iterate through the values provided in start and end. Typically needs to be .01
#pass the start color and ending color in the 'Color(255,255,255) format. Pass a wait time or delay, ie. .01
def wipe(dict_name, start, end, step, color1, color2, wait):
    #Need to find duplicate values (lat/lons) from dictionary using flip technique
    flipped = {}
    for key, value in dict_name.items(): #create a dict where keys and values are swapped
        if value not in flipped:
            flipped[value] = [key]
        else:
            flipped[value].append(key)

    for i in frange(start,end,step):
        key = str(i)
        if key in flipped: #Grab latitude from dict
            num_elem = (len(flipped[key])) #Determine the number of duplicates
#                        print ("num_elem = " + str(num_elem)) #debug

            for j in range(num_elem): #loop through each duplicate to get led number
#                               print (j)      #debug
#                                print (key) #Latitude - debug
                id = (flipped[key][j])
#                                print (id) #Airport ID - debug

                led_pin = ap_id.index(id) #Assign the pin number to the led to turn on/off
#                                print (led_pin) #print led pin number to wipe through - debug
#                                print #debug

                strip.setPixelColor(led_pin, randcolor()) #color1)
                strip.show()
                time.sleep(wait)
                strip.setPixelColor(led_pin, Color(0,0,0))
                strip.show()

#Circle wipe
def circlewipe(centerlat,centerlon,iter,color1,color2):
    global apinfodict
    circle_x = centerlon
    circle_y = centerlat
    rad = .5
    color = randcolor()

    for j in range(iter):
        for key in apinfodict:
            print (key)
            x = float(apinfodict[key][2])
            y = float(apinfodict[key][1])
            pin = int(apinfodict[key][0])
            print (x, y, pin)

            if ((x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad):
#                                print("Inside")
                strip.setPixelColor(pin, color)
            else:
#                                print("Outside")
                strip.setPixelColor(pin, color2)
            strip.show()
#                        time.sleep(.01)
        rad = rad +.25
    allonoff(Color(0,0,0),.1)

#radar wipe - Needs area calc routines to determine areas of triangles
def area(x1, y1, x2, y2, x3, y3):
    return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)
#        return round(((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0),2)

def isInside(x1, y1, x2, y2, x3, y3, x, y):
    # Calculate area of triangle ABC
    A = area (x1, y1, x2, y2, x3, y3)
    # Calculate area of triangle PBC
    A1 = area (x, y, x2, y2, x3, y3)
    # Calculate area of triangle PAC
    A2 = area (x1, y1, x, y, x3, y3)
    # Calculate area of triangle PAB
    A3 = area (x1, y1, x2, y2, x, y)
    # Check if sum of A1, A2 and A3 is same as A
    if(A == A1 + A2 + A3):
        return True
    else:
        return False

def radarwipe(centerlat,centerlon,iter,color1,color2,sweepwidth=175,radius=50,angleinc=.05):
    global apinfodict
    PI = 3.141592653
    angle = 0
    color = randcolor()

    for k in range(iter):
        # Calculate the x1,y1 for the end point of our 'sweep' based on
        # the current angle. Then do the same for x2,y2
        x1 = round(radius * math.sin(angle) + centerlon,2)
        y1 = round(radius * math.cos(angle) + centerlat,2)
        x2 = round(radius * math.sin(angle + sweepwidth) + centerlon,2)
        y2 = round(radius * math.cos(angle + sweepwidth) + centerlat,2)

        for key in apinfodict:
#                        print (key) #Airport code
            px1 = float(apinfodict[key][2]) #Lon
            py1 = float(apinfodict[key][1]) #Lat
            pin = int(apinfodict[key][0]) #LED Pin Num
#                        print (centerlon, centerlat, x1, y1, x2, y2, px1, py1, pin) #debug

            if (isInside(centerlon, centerlat, x1, y1, x2, y2, px1, py1)):
#                               print('Inside')
                strip.setPixelColor(pin, color)
            else:
                strip.setPixelColor(pin, color2)
#                                       print('Not Inside')

        strip.show()
#               raw_input("enter:")
#               time.sleep(.01)

        # Increase the angle by 0.03 radians
        angle = angle + angleinc
#               print (angle) #debug

        # If we have done a full sweep, reset the angle to 0
        if angle > 2 * PI:
            angle = angle - 2 * PI

#Square wipe
#findpoint in a given rectangle or not.   Example -114.87, 37.07, -109.07, 31.42, -114.4, 32.87
def findpoint(x1, y1, x2, y2, x, y):
    if (x > x1 and x < x2 and y > y1 and y < y2):
        return True
    else:
        return False

def center(max,min):
    z = ((max-min)/2) + min
    return round(z,2)

def squarewipe(minlon,minlat,maxlon,maxlat,iter=2,color1=Color(255,255,255),color2=Color(0,0,0),step=.1,wait=.01):
    global apinfodict
    declon = minlon
    declat = minlat
    inclon = maxlon
    inclat = maxlat
    centlon = (center(maxlon,minlon))
    centlat = (center(maxlat,minlat))
    color1 = randcolor()
    color2 = randcolor()


    print ("minlon "+str(minlon)+" minlat "+str(minlat)+" maxlon "+str(maxlon)+" maxlat "+str(maxlat)) #debug
    print (centlon,centlat) #debug

    for j in range(iter):
        for inclon in frange(maxlon, centlon, step):
            #declon, declat = Upper Left of box.
            #inclon, inclat = Lower Right of box
            for key in apinfodict:
#                                print (key) #Airport code #debug
                px1 = float(apinfodict[key][2]) #Lon
                py1 = float(apinfodict[key][1]) #Lat
                pin = int(apinfodict[key][0]) #LED Pin Num

                print (declon, declat, inclon, inclat, px1, py1) #debug
                if findpoint(declon, declat, inclon, inclat, px1, py1):
                    print('Inside') #debug
                    strip.setPixelColor(pin, color1)
                else:
                    print('Not Inside') #debug
                    strip.setPixelColor(pin, color2)

            inclat = round(inclat - step,2)
            declon = round(declon + step,2)
            declat = round(declat + step,2)

            strip.show()
            time.sleep(wait)
        print #debug
        print #debug

        for inclon in frange(centlon, maxlon, step):
            #declon, declat = Upper Left of box.
            #inclon, inclat = Lower Right of box
            for key in apinfodict:
#                                print (key) #Airport code #debug
                px1 = float(apinfodict[key][2]) #Lon
                py1 = float(apinfodict[key][1]) #Lat
                pin = int(apinfodict[key][0]) #LED Pin Num

                print (declon, declat, inclon, inclat, px1, py1)
                if findpoint(declon, declat, inclon, inclat, px1, py1):
                    print('Inside') #debug
                    strip.setPixelColor(pin, color1)
                else:
                    print('Not Inside') #debug
                    strip.setPixelColor(pin, color2)

            inclat = round(inclat + step,2)
            declon = round(declon - step,2)
            declat = round(declat - step,2)

            strip.show()
            time.sleep(wait)

    allonoff(Color(0,0,0),.1)

#Turn on or off all the lights using the same color.
def allonoff(color1,wait):
    for i in range(strip.numPixels()):
        strip.setPixelColor(i, color1)
    strip.show()
    time.sleep(wait)

#Start of executed code
toggle = 0 #used for homeport display
outerloop = 1 #Set to TRUE for infinite outerloop
while (outerloop):

    #Dictionary definitions. Need to reset whenever new weather is received
    stationiddict = {}
    windsdict = {}
    wxstringdict = {}
    latdict = {}    #airport id and its latitude
    londict = {}    #airport id and its longitude
    pindict = {}    #Stores airport id and led pin number
    apinfodict = {} #Holds pin num as key and a list to include [airport id, lat, lon]

#       rainbowCycle(strip, iterations) #Display Rainbow Pattern to signify updating. Set iterations to 0 to disable.

    #read airports file - read each time weather is updated in case a change to "airports" file was made while script was running.
    with open("/NeoSectional/airports") as f:
        airports = f.readlines()
    airports = [x.strip() for x in airports]

    #Define URL to get weather METARS. This will pull only the latest METAR from the last 2.5 hours. If no METAR reported withing the last 2.5 hours, Airport LED will be white.
    url = "https://www.aviationweather.gov/adds/dataserver_current/httpparam?dataSource=metars&requestType=retrieve&format=xml&mostRecentForEachStation=constraint&hoursBeforeNow="+str(metar_age)+"&stationString="

    #Build URL to submit to FAA with the proper airports from the airports file and populate the pindict dictionary
    i = 0
    for airportcode in airports:
        if airportcode == "NULL" or airportcode == "LGND":
            i += 1
            continue
        url = url + airportcode + ","
        pindict[airportcode] = str(i) #build a dictionary of the LED pins for each airport used
        i += 1
    print (pindict)
    print
#       sys.exit()

    try: #Simple Error trap, in case FAA web site is not responding
        content = urllib2.urlopen(url).read()
    except: #End of Error trap
        pass

    root = ET.fromstring(content) #Process XML data returned from FAA

    #grab the airport category, wind speed and various weather from the results given from FAA.
    for metar in root.iter('METAR'):
        print (metar)

        if airportcode == "NULL" or airportcode == "LGND": #if airport code is NULL, then bypass
            continue
        stationId = metar.find('station_id').text
        print (stationId)

        #grab flight category from returned FAA data
        if metar.find('flight_category') is None: #if category is blank, then bypass
            flightcategory = "NONE"
        else:
            flightcategory = metar.find('flight_category').text

        #grab wind speeds from returned FAA data
        if metar.find('wind_speed_kt') is None: #if wind speed is blank, then bypass
            windspeedkt = 0
        else:
            windspeedkt = metar.find('wind_speed_kt').text

        #grab Weather info from returned FAA data
        if metar.find('wx_string') is None: #if weather string is blank, then bypass
            wxstring = "NONE"
        else:
            wxstring = metar.find('wx_string').text

        #grab latitude of airport
        if metar.find('latitude') is None: #if weather string is blank, then bypass
            lat = 0
        else:
            lat = metar.find('latitude').text

        #grab longitude of airport
        if metar.find('longitude') is None: #if weather string is blank, then bypass
            lon = 0
        else:
            lon = metar.find('longitude').text

        #Check for duplicate airport identifier and skip if found, otherwise store in dictionary. covers for dups in "airports" file
        if stationId in stationiddict:
            print ("Duplicate, only saved first metar category")
        else:
            stationiddict[stationId] = flightcategory #build category dictionary

        if stationId in windsdict:
            print ("Duplicate, only saved the first winds")
        else:
            windsdict[stationId] = windspeedkt #build windspeed dictionary

        if stationId in wxstringdict:
            print ("Duplicate, only saved the first weather")
        else:
            wxstringdict[stationId] = wxstring #build weather dictionary

        if stationId in latdict:
            print ("Duplicate, only saved the first weather")
        else:
            latdict[stationId] = lat #build latitude dictionary

        if stationId in londict:
            print ("Duplicate, only saved the first weather")
        else:
            londict[stationId] = lon #build longitude dictionary

        apinfodict[stationId]=[pindict[stationId],lat,lon] #Build Dictionary with structure:{airport id[pin num,lat,lon]}

        print (apinfodict)
        print (latdict)
        print (londict)

    #build necessary lists to find proper Lat/Lons (Try to eliminate and use apinfodict instead)
    for key, value in latdict.iteritems():
        temp = float(value)
        latlist.append(temp)
    print (latlist)         #debug
    print                   #debug

    for key, value in londict.iteritems():
        temp = float(value)
        lonlist.append(temp)
    print (lonlist)         #debug
    print                   #debug

    for airportcode in airports:
        ap_id.append(airportcode)
#       print (ap_id)           #debug
#       print                   #debug

    #set the maximum and minimum Lat/Lons to constrain area.
    maxlat = max(latlist) #Upper bounds of box
    minlat = min(latlist) #Lower bounds of box
    maxlon = max(lonlist) #Right bounds of box
    minlon = min(lonlist) #Left bounds of box
    sizelat = abs(maxlat - minlat) #height of box
    sizelon = abs(maxlon - minlon) #width of box

    centerlat = round((maxlat-minlat)/2+minlat,2) #center y coord of box
    centerlon = round((maxlon-minlon)/2+minlon,2) #center x coord of box

    print ("minlon "+str(minlon)+" minlat "+str(minlat)+" maxlon "+str(maxlon)+" maxlat "+str(maxlat))

#       print randcolor()
#       sys.exit()

    #square wipe - provide coord of box and size, iterations, and colors
    squarewipe(minlon,minlat,maxlon,maxlat,1,Color(00,250,00),Color(0,0,0))

#       sys.exit()

    #radar wipe - provide center of map and the number of times to cycle through
    radarwipe(centerlat,centerlon,720,Color(200,00,00),Color(0,0,0))

#       sys.exit()

    #Circle wipe. provide center coordinates and number of iterations, provide inside of circle color then outside of circle.
    circlewipe(centerlat,centerlon,10,Color(00,00,250),Color(0,0,0))

    #Wipe from bottom to top and back, then side to side
    for x in range(4):
        wipe(latdict, minlat, maxlat, .01, Color(255,255,255), Color(0,0,0), .01)
        wipe(latdict, maxlat, minlat, .01, Color(255,255,255), Color(128,0,255), .01)
        wipe(londict, minlon, maxlon, .01, Color(255,127,0), Color(0,0,0), .01)
        wipe(londict, maxlon, minlon, .01, Color(255,127,0), Color(0,255,127), .01)

    #change colors on whole board
    for x in range(1):
        allonoff(randcolor(),1) #Color(255,0,0),1)
        allonoff(randcolor(),1) #Color(0,255,0),1)
        allonoff(randcolor(),1) #Color(0,0,255),1)

    #rainbow effect
    rainbowCycle(strip, 2)

#       sys.exit()
